<!DOCTYPE html>
<html lang="en" dir="ltr">
	<head>
		<meta charset="utf-8">
		<link rel="stylesheet" href="css/themes.css">
		<link rel="stylesheet" href="css/uPlot.min.css">
		<link rel="stylesheet" href="css/tab.css">
		<style media="screen">
			.graph {
				--font: DejaVu Sans Mono, Liberation Mono, monospace;
				background-color: var(--color-bg);
				color: var(--color-text);
				font-family: var(--font);
				font-size: 14px;
				margin: 8px 2px 0 0;
			}
			.u-series, .u-value, .u-title {
				font-family: var(--font);
			}
			#updated {
				font-style: italic;
				color: var(--color-grid);
				position: absolute;
				left: 32px;
				bottom: 48px;
			}
			#warn {
				font-style: italic;
				color: var(--color-grid);
				position: absolute;
				left: 32px;
				bottom: 32px;
			}
			#popup {
				background-color: var(--color-bg);
				opacity: 0.95;
				position: absolute;
				display: inline-block;
				visibility: hidden;
				z-index: 1;
				top: 6px;
				width: 475px;
				border: 2px var(--color-inactive) dashed;
			}
			#popup.show {
				visibility: visible;
			}
		</style>
		<title>Circles</title>
	</head>
	<body main-theme="dark" class="graph">
		<span id="updated">Loading..</span>
		<span id="warn"></span>
		<div id="popup"></div>
		<script type="module">
			import {receiveData, initDetailsPlot} from './js/applications/circles.js';
			import {constructQueryManager} from './js/lib/util.js';
			const opts = new Proxy(new URLSearchParams(window.location.search), {
				get: (searchParams, prop) => searchParams.get(prop),
			});
			if (opts.bg)
				document.body.style.backgroundColor = '#' + opts.bg;
			const days = parseInt(opts.days) || 7;
			let updateDelay = parseInt(opts.update) || 20;
			if (updateDelay < 5) updateDelay = 5;
			const delayMs = updateDelay * 60 * 1000;
			let updated, params, middle;
			const popup = document.getElementById('popup');
			const updt = document.getElementById('updated');
			const warn = document.getElementById('warn');
			popup.onclick = () => { popup.classList.remove('show') }
			const query = constructQueryManager('api/neutron/circles', {
				data: resp => {
					updated = Date.now();
					updt.innerHTML = `Updated just now`;
					warn.innerHTML = '';
					if (resp.excluded && resp.excluded.length)
						warn.innerHTML += `Excluded: ${resp.excluded.join()}`
					if (resp.filtered)
						warn.innerHTML += ` Filtered: ${resp.filtered}`
					receiveData(resp, plotClick);
					middle = resp.time[Math.floor(resp.time.length / 2)]
					setInterval(() => {
						const sec = (Date.now() - updated) / 1000;
						if (sec < 60)
							updt.innerHTML = `Updated ${sec.toFixed()} second${sec<2?'':'s'} ago`;
						else
							updt.innerHTML = `Updated ${Math.floor(sec/60)} minute${sec<120?'':'s'} ago`;
					}, 1000);
				}
			}, false, 5000);
			async function plotClick(time) {
				console.log('%cclick', 'color: #f0f', time);
				const query = `api/neutron/circles?from=${params.from}&to=${params.to}&details=${time}`
				const res = await fetch(query + (params.exclude?.length ? `&exclude=${params.exclude}` : ''));
				if (res.status == 200) {
					const body = await res.json();
					console.log(body);
					if (!body.time) return popup.classList.remove('show');
					popup.style.left = time >= middle ? '76px' : 'unset';
					popup.style.right = time < middle ? '6px' : 'unset';
					popup.classList.add('show');
					initDetailsPlot(body, popup);
				} else {
					console.log('%cfailed to get details:', 'color: #f0a', res.status);
				}
			}
			function fetchdata() {
				params = {
					from: Math.floor(new Date().getTime() / 1000 - 86400 * days),
					to:   Math.floor(new Date().getTime() / 1000),
					exclude: opts.exclude || null,
					window: opts.window || null,
					minamp: opts.minamp || null
				};
				updt.innerHTML = `Updating...`;
				query.fetch(params);
				setTimeout(fetchdata, delayMs);
			}
			fetchdata();
		</script>

	</body>
</html>
